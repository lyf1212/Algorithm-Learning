#### [808. 分汤](https://leetcode.cn/problems/soup-servings/)

有 **A 和 B 两种类型** 的汤。一开始每种类型的汤有 `n` 毫升。有四种分配操作：

1. 提供 `100ml` 的 **汤A** 和 `0ml` 的 **汤B** 。
2. 提供 `75ml` 的 **汤A** 和 `25ml` 的 **汤B** 。
3. 提供 `50ml` 的 **汤A** 和 `50ml` 的 **汤B** 。
4. 提供 `25ml` 的 **汤A** 和 `75ml` 的 **汤B** 。

当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 `0.25` 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。

**注意** 不存在先分配 `100` ml **汤B** 的操作。

需要返回的值： **汤A** 先分配完的概率 + **汤A和汤B** 同时分配完的概率 / 2。返回值在正确答案 $10^{-5}$ 的范围内将被认为是正确的。

**示例 1:**

```
输入: n = 50
输出: 0.62500
解释:如果我们选择前两个操作，A 首先将变为空。
对于第三个操作，A 和 B 会同时变为空。
对于第四个操作，B 首先将变为空。
所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。
```

##### 思路：动态规划

可以设$dp[i][j]$为$A$剩$i$而$B$剩$j$的汤没有分配完时，欲求的最终概率。

最终答案应该返回$dp[n][n]$。

从时间线的前向后推：
$$
dp[i][j]=0.25*(dp[i-4][j]+dp[i-3][j-1]+dp[i-2][j-2]+dp[i-1][j-3]).
$$
但是具体到代码中，$i:1 \to n$		$j:1 \to n$去更新状态，所以对应于原题中“如果汤的剩余量不足以完成某次操作，我们将尽可能分配”，应该把可能负溢出的下标使用$max(0,\cdot)$将之合理限定住。

##### 一个技巧：

本题说小于$1e-5$的误差是可以接受的，所以对于较大的n可以直接返回值。这里试出来是$n=4800$时就是答案就和$1$精度差小于$1e-5$了。

##### Code：

```C++
class Solution {
public:
    double soupServings(int n) {
        double dp[200][200] = {0.0};
        if(n>=4800)     // 精度是1e-5.
            return 1;
        int t = n%25;
        // 可以视25为一份.
        n/=25;
        if(t)   n++;    // 向上取整.
        
        for(int i=1;i<=n;i++)
            dp[0][i]=1;
        dp[0][0]=0.5;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                dp[i][j]=0.25 * (
                dp[max(0,i-4)][j]
                +dp[max(0,i-3)][j-1]
                +dp[max(0,i-2)][max(0,j-2)]
                +dp[i-1][max(0,j-3)]);  // 取大于0的：“不足的尽量分配”.
            }
        }
        return dp[n][n];

    }
};
```

